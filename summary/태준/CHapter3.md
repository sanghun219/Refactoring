<br>

# Chapter3 코드에서 나는 악취

<br><br>

---

<br><br>

크게 성공한 프로젝트부터 거의 망한 프로젝트까지 폭넓은 코드들을 보아오면서 리펙터링이 필요한, 때로는 아주 절실한 코드들에 일정한 패턴이 있다는 사실을 발견했다.

리팩터링하면 해결할 수 있는 문제의 징후를 제시하겠다.

<br>

기이한 이름
- 세계적인 기인이라는 느낌을 풍기고 싶더라도 꾹 참고 코드는 단순하고 명료하게 작성해야 한다.
- 코드를 명료하게 표현하는 데 가장 중요한 요소 하나는 바로 '이름'이다.

<br>

중복 코드
- 똑같은 코드 구조가 여러 곳에서 반복된다면 하나로 통합하여 더 나은 프로그램을 만들 수 있다.

<br>

긴 함수
- 오랜 기간 잘 활용되는 프로그램들은 하나같이 짧은 함수로 구성
- 적극적으로 함수를 쪼개야 한다.

<br>

긴 매개변수 목록
- 매개변수 목록이 길어지면 그 자체로 이해하기 어려울 때가 많다.

<br>

전역 데이터
- 전역 데이터는 코드베이스 어디에서든 건드릴 수 있고 누가 바꿨는지 찾아낼 메커니즘이 없다는 문제가 있다.

<br>

가변 데이터
- 함수형 프로그래밍에서 데이터는 절대 변하지 않고, 데이터를 변경하려면 반드시 변경하려는 값에 해당하는 복사본을 만들어서 반환한다는 개념을 기본으로 삼고 있다.

<br>

뒤엉킨 변경
- 소프트웨어는 자고로 소프트해야 마땅하다.
- 단일 책임 원칙이 제대로 지켜지지 않을 때 나타난다.

<br>

산탄총 수술
- 이 냄새는 코드를 변경할 때마다 자잘하게 수정해야 하는 클래스가 많을 때 풍긴다.

<br>

기능 편애
- 흔히 어떤 함수가 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 상호작용 할 일이 더 많을 때 풍기는 냄새

<br>

데이터 뭉치
- 판별하려면 값 하나를 삭제해보자. 그랬을 때 나머지 데이터만으로는 의미가 없다면 객체로 환생하길 갈망하는 데이터 뭉치라는 뜻

<br>

기본형 집착
- 문자열을 다루는 코드에서 흔하다.

<br>

반복되는 switch문
- 문제가 되는 이유는 조건절을 하나 추가할 때마다 다른 switch문들도 모두 찾아서 함께 수정해야 하기 때문이다.

<br>

반복문
- 필터나 맵같은 파이프라인 연산을 사용하면 코드에서 각 원소들이 어떻게 처리되는지 쉽게 파악 가능하다.

<br>

성의 없는 요소
- 우리는 코드의 구조를 잡을 때 프로그램 요소를 이용하는 걸 좋아해서 생긴다.

<br>

추측성 일반화
- '나중에 필요할 거야'라는 생각으로 당장은 필요 없는 모든 종류의 후킹 포인트와 특이 케이스 처리 로직을 작성해든 코드에서 생긴다.

<br>

임시 필드
- 임시 필드를 갖도록 작성하면 코드를 이해하기 어렵다.

<br>

메시지 체인
- 클라이언트가 한 객체를 통해 다른 객체를 얻은 뒤 방금 얻은 객체에 또 다른 객체를 요청하는 식으로, 다른 객체를 요청하는 작업이 연쇄적으로 이어지는 코드를 말한다.
- 내비게이션 중간 단계를 수정하면 클라이언트 코드도 수정해야 한다.

<br>

중개자
- 클래스가 제공하는 메서드가 대부분 다른 클래스에 구현된 경우

<br>

내부자 거래


<br>

거대한 클래스
- 한 클래스가 너무 많은 일을 하려다 보면 필드 수가 상당히 늘어나고, 필드가 너무 많으면 중복 코드가 생기기 쉽다.

<br>

서로 다른 인터페이스의 대안 클래스들


<br>

데이터 클래스
- 데이터 필드와 게터/세터 메서드로만 구성된 클래스를 말한다.
- 저장 용도로만 쓰이다 보니 다른 클래스가 너무 깊이까지 함부로 다룰때가 많다.

<br>

상속 포기
- 서브 클래스는 부모로부터 메서드와 데이터를 물려받는다. 하지만 필요없는 유산이 껴있는 경우도 있다.

<br>

주석
- **주석을 남겨야겠다는 생각이 들면, 가장 먼저 주석이 필요 없는 코드로 리펙터링해본다.**

<br>